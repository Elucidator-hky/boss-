# 阶段1开发计划（最新版）

## 目标
Boss 直聘 `/web/geek/chat` 页面自动生成 HR 常问问题的基础回复，填入输入框但不自动发送。

## 数据准备
- 个人信息：城市、离职状态、工作年限、学历、求职方向、技术栈（必填）；上一份薪资、离职时间、离职原因、项目亮点、自定义字段（可选）。
- 模型设置：API Base、API Key、模型名称。
- 存储键：`profile_static`、`settings`、`drafts`、`whitelist`。
- 模型接口：OpenAI 兼容 `POST /v1/chat/completions`，入参 `{profile_static, conversationKey, messages}`，出参 `{conversationKey, reply, can_answer, missing_fields}`。超时 8-10s，失败重试 1 次。

## 开发步骤
1. **项目骨架 ✅**  
   - 已完成：`manifest.json`、`src/options`、`src/popup`。  
   - 待补：`src/content`、`src/background`、`dist`。

2. **Options 配置页 ✅**  
   - 有表单、`chrome.storage.local` 读写、导入导出、必填校验。  
   - Popup 按钮可打开完整配置页。

3. **内容脚本（待做）**  
   - `manifest.json` 的 `content_scripts` 设置 `matches: ["https://www.zhipin.com/web/geek/chat*"]`，脚本 `src/content/index.js`。  
   - 内容脚本启动：`if (!location.pathname.includes("/web/geek/chat")) return;`。  
   - 会话识别（先用单一方案，后续如页面改动再调整）：  
     - 通过当前激活会话 DOM（如 `.chat-item.active`）读取 `data-chatid`（或同类稳定属性）作为 `conversationKey`。  
     - 找不到 active 会话就读取会话列表的第一项；如仍为空则提示用户手动点击会话。  
   - 使用 `MutationObserver` 监听会话列表点击/激活状态变化，更新 `currentConversationKey` 并通过 `window.dispatchEvent(new CustomEvent("boss-chat-key", { detail: key }))` 通知其他逻辑。  
   - 读取 `chrome.storage.local` 的 `profile_static`/`settings`，若缺失就通过 toast 提示用户打开配置页。

4. **消息抽取与触发（待做）**  
   - 在内容脚本实现 `collectMessages(max)`：  
     - 找到聊天消息容器（如 `.chat-msg-list`），取最后 `max_msgs` 个节点。  
     - 根据节点 class 判断 sender（HR/我），提取纯文本，生成 `[{role:"hr"|"me", text}]`。  
     - 过滤空白文本或系统提示。  
   - 写 `watchNewMessages()`：  
     - 用 `MutationObserver` 监听消息容器新增节点。  
     - 若新节点 role=HR，且没有在 `processedSet` 中，则调用 `handleHrMessage()`。  
     - `handleHrMessage()` 内部做节流：`throttle_ms`（默认 5000ms）。  
     - 去重 key = 文本 + 时间戳或数据属性；存入 `processedSet`。

5. **背景脚本调用模型（待做）**  
   - `manifest.json` 加 `background":{"service_worker":"src/background/index.js","type":"module"}`。  
   - `src/background/index.js`：  
     - 监听 `chrome.runtime.onMessage`，处理类型 `GENERATE_REPLY`。  
     - 从 `chrome.storage.local` 读取 `settings`/`profile_static`，确保必填字段非空。  
     - 组装模型请求体：`{ model, messages: [...], metadata:{conversationKey}, profile_static }`（按 API 结构调整）。  
     - 使用 `fetch` + `AbortController` 控制 8-10s 超时。遇到 429/5xx → `await wait(500)` 后重试一次。  
     - 成功时返回 `{ reply, conversationKey, can_answer, missing_fields }`，失败时返回 `{ error }`。

6. **填充输入框与防误填（待做）**  
   - content script 接收 background 回调：  
     - 先比对 `response.conversationKey === currentConversationKey`。  
     - 选择输入框 DOM（textarea 或 contenteditable）。  
     - 若输入框值为空 → 写入 `reply`，触发 `input` 事件。  
     - 若非空 → 显示 toast “输入框有内容，不自动覆盖”。  
     - 不触发发送按钮。

7. **草稿保存与恢复（待做）**  
   - 在会话列表 `click` 事件或输入框 `blur` 时，将当前输入保存到 `drafts[conversationKey]`。  
   - 切换会话后：  
     - 清空输入框，标记 `currentConversationKey`。  
     - 检查 `drafts[currentConversationKey]`，若存在 → 显示“恢复草稿”按钮/提示；用户点击后填充草稿并删除存储。  
   - 草稿保存/恢复都显示 toast（后续 UI 步骤实现）。

8. **提示 UI（待做）**  
   - 在内容脚本注入 `<div id="boss-helper-toast"></div>`，样式控制位置在输入框上方或右上角。  
   - 封装 `showToast(type, text, duration)`，type: info/success/error/warning。  
   - 触发场景：  
     1) 未配置 → warning.  
     2) 生成中 → info.  
     3) 生成成功 → success.  
     4) 模型错误/缺字段 → error/warning，并列出字段名。  
     5) 草稿保存/恢复 → success/info。  
   - 确保不遮挡输入框/最近消息。

9. **构建与手测（待做）**  
   - 编写 `npm run build`：复制 `manifest`、`src` 到 `dist`，再压缩为 zip。  
   - 手测清单：  
     1) 未配置不触发，toast 提示去配置。  
     2) 输入框非空不覆盖。  
     3) 切换会话草稿保存/恢复正常。  
     4) HR 连续消息 → 节流只触发一次。  
     5) 模型超时/429 提示明显。  
     6) 模型返回缺字段 → 列出字段并不填草稿。  
     7) 长对话（>max_msgs） → 仍能生成。  
     8) 打包 zip 能在 `chrome://extensions` 成功加载。

## 时间预估
- Day 1：完成内容脚本骨架（步骤 3-4）。  
- Day 2：完成背景脚本 + 模型调用（步骤 5）。  
- Day 3：完成填充/草稿/提示（步骤 6-8）。  
- Day 4：打包 & 手测（步骤 9），预留 0.5 天修复。
